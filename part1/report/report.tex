% XeLaTeX can use any Mac OS X font. See the setromanfont command below.
% Input to XeLaTeX is full Unicode, so Unicode characters can be typed directly into the source.

% The next lines tell TeXShop to typeset with xelatex, and to open and save the source with Unicode encoding.

%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\documentclass[12pt]{ctexart}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
%\geometry{landscape}                % Activate for for rotated page geometry
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{tabularx}
\usepackage{amsmath}
\usepackage{mathrsfs}
\usepackage{listings}
\usepackage{color}
\usepackage{hyperref}
\usepackage{amsthm}
\usepackage{chemfig}
\usepackage{mhchem}

% Will Robertson's fontspec.sty can be used to simplify font choices.
% To experiment, open /Applications/Font Book to examine the fonts provided on Mac OS X,
% and change "Hoefler Text" to any of these choices.

\usepackage{fontspec,xltxtra,xunicode}

\providecommand*{\unit}[1]{\ensuremath{\mathrm{\,#1}}}
\newcommand{\di}{\ensuremath{\mathrm{\,d}}}

% \setmonofont{Source Code Pro}

\setCJKmainfont{Noto Serif CJK SC}

\CTEXsetup[format={\large\bfseries}]{section}

\title{IOI2020 国家集训队第一阶段作业第一部分解题报告}
\author{北京大学附属中学\quad 李白天}
% \date{}

\begin{document}

\maketitle

\section{Codeforces 559E Gerald and Path}

\subsection{题目大意}

有 $n$ 组有序数对 $(a_i, l_i)$，对于每个 $i$ 有两种选择，将数轴上的 $[a_i - l_i, a_i]$ 这条线段染色或者将 $[a_i, a_i + l_i]$ 这条线段染色。求最大化的最终被染色总线段长度。

\subsection{数据范围}

输入均为整数，$1\le n\le 100, 0\le a_i\le 10^8, 1\le l_i\le 10^8$，保证 $a_i$ 互不相同。

\subsection{解题过程}

本题官方给出的是一个 $\Theta(n^4)$ 的做法，但实际上本题可以在 $\Theta(n^2)$ 的时间内解决。

考虑在第一步枚举最优解中被染色的最右端点来自哪个 $i$，由于我们已经枚举了最右端点，那么在 $(a_i, a_i + l_i)$ 区间内的 $a_j$ 都不必要选取向右延伸，因为在这种枚举方式下已经假设这段区间的右端不可改进，故要求它们均向左延伸。进一步地，如果在这段区间内的 $a_j - l_j$ 之最小值 $< a_i$，则说明区间的左端可以得到扩展，扩展后新的被包含的 $a_j$ 同理要被如此考虑，直至区间无法进一步扩展。

于是在规划剩余的 $i$ 时，还需考虑到与之前原有线段可能有交。我们考虑动态规划。$f(x)$ 表示假设之前已经规划的部分左端点为 $x$，接下来规划所有 $a_i < x$ 的 $i$ 对应的方案，总线段与 $(-\infty, x]$ 的交长度的最大值。$f(+\infty)$ 即为答案。关键点只有所有的 $a_i, a_i\pm l_i$，因此总共只有 $\Theta(n)$ 种，可以将状态离散化。

对于之前的扩展部分，我们首先可以预处理每个区间内 $a_i - l_i$ 的最小值，通过区间最小值递推出每个区间最终向左扩展出的区间。这一部分的时间复杂度为 $\Theta(n^2)$。

动态规划总共有 $\Theta(n)$ 个状态，每个状态有 $\Theta(n)$ 种转移方式，通过上述预处理可以将转移结果 $\Theta(1)$ 算出。

综上所述，本题可以在 $\Theta(n^2)$ 时间复杂度内解决。

\newpage

\section{AGC 037E Reversing and Concatenating}

\subsection{题目大意}

给一个长为 $n$ 的字符串 $S$，进行 $k$ 次操作，每次首先将 $S$ 的翻转 $T$ 与 $S$ 拼接成一个长为 $2n$ 的字符串 $ST$，然后选取一个长为 $n$ 的子串作为新的 $S$，要求最小化 $k$ 次操作后的字符串，要求字典序最小。

\subsection{数据范围}

$1\le n\le 5000, 1\le k\le 10^9$。

\subsection{解题过程}

首先容易注意到 $k$ 只要超过 $\log n$ 的量级就没有意义，因为设字符串的最小字符为 $c$，可能生成的字符串不难得到一个下界，即一个长为 $n$ 的，每个字符都是 $c$ 的字符串。这可以在第一次操作的时候使 $c$ 作为末尾出现，之后每次操作都会由 $ST$ 中间部分使得 $c$ 的连续段倍长。因此设这一连续段长度为 $L$，只需 $L2^{k-1} \ge n$ 即可让最后整段均为 $c$。

接下来考虑 $L2^{k-1} < n$ 的情况，这启发我们同样从最小字符的角度考虑。为了使得字典序最小，我们首先需要保证得到串开头的 $c$ 前缀尽量长，考虑最初的 $ST$ 中最长的 $c$ 连续段为 $L$，我们之后每次操作必然可以使长度倍增，而剩下的其余 $c$ 段（设长度 $l$）由于没有在中间的位置，故不可能倍增，只有 $l \le L < 2L$，因此在接下来选定了倍长哪一段后，没有长度大于等于它的，接下来的操作必定是将其一直倍长。考虑最终状态，假设原字符串中这一连续段所占据位置为 $S_j = S_{j + 1} = \cdots = S_{j + L - 1} = c$，则终态 $S'$ 在最后截取长度为 $n$ 的段前，是一个长度为 $2n$ 的回文串，原本连续段起点之前的前缀部分 $\dots, S_{j-2}, S_{j-1}$ 的一个后缀得以保留，因此最后的 $S'$ 是形如 $L 2^{k-1}$ 个 $c$ 再加上 $S_{j-1}, S_{j - 2}, \dots$。

为了确认最初的决策点，我们需要将每个长度达到最大值 $L$ 的 $c$ 的连续段，其前面部分的前缀 $pre(j - L)$ 的字符串翻转的结果中找到字典序最小的，截取前 $n - L2^{k-1}$ 位，与连续段拼接后就是答案。

如果我们暴力进行字符串比较，则可以做到 $\Theta(n^2)$，可以通过本题。而找到这些前缀的翻转中最小的那一个，还可以通过各种后缀排序的算法解决，因此本题可以做到 $\Theta(n\log n)$ 或者 $\Theta(n)$。

\end{document}
